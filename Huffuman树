问题描述
例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：
　　1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。
　　2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。
　　3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。
　　4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。
　　5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。
输入格式
　　输入的第一行包含一个正整数n（n<=100）。
　　接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。
输出格式
　　输出用这些数构造Huffman树的总费用。
样例输入
5
5 3 8 2 9
样例输出
59

代码
#include<stdio.h>
int main()
{
	int n,i,j,min1,min2;//min1为最小数下标，min2为次小数下标 
	int a[100];
	long long he=0;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	scanf("%d",&a[i]);
	for(i=n;i>1;i--)
	{
		min1=0;min2=1;
		if(a[1]<a[0])
		min1=1,min2=0;
		for(j=2;j<i;j++)
		{
			if(a[j]<a[min2])
			{
				if(a[j]<a[min1])
				min2=min1,min1=j;
				else
				min2=j;
			}
		}
		a[min1]+=a[min2];
		he+=a[min1];
		for(j=min2;j<i-1;j++)
		{
			a[j]=a[j+1];
		}
	}
	printf("%I64d\n",he);
	
	return 0;
}
