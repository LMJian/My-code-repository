
问题描述

小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。

小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。

现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, … AN。

小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？

输入

第一行包含两个个整数N和K。
第二行包含N个整数A1, A2, … AN。

对于30%的数据，1 <= N <= 10
对于100%的数据，1 <= N <= 100000, 0 <= Ai <= 100000, 0 <= K <= 100000

输出

一个整数，代表答案。

样例输入：
10 0
1 4 2 8 5 7 1 4 2 8

样例输出：
6

再比如，
样例输入：
10 1
2 1 1 1 1 4 4 3 4 4

样例输出：
8

资源约定：
峰值内存消耗 < 256M
CPU消耗 < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。
难点
难点在于dp的思想不能熟练运用，思路不对
此题是找到k的等差数列，运用dp推导找到数列的最大值，所有数列的最大值加起来便是答案，因为数列之间是没有相差为k的数。
代码

#include<stdio.h>
#define M 100001
#define max(a,b) a>b?a:b

int n,k;
int arr[M]={0};
int maze[M]={0};
int dp[M]={0};

int breach()
{
	int mlen=0;
	int sum=0;
	int i,j;
	if(k==0)
	{
		for(i=0;i<M;i++)
		{
			if(arr[i]!=0)
			sum++;
		}
	}
	else
	for(i=0;i<k;i++)//k等差数列的起点    数据中可能有0，所以从o开始 
	{
		mlen=0;
		for(j=i;j<M;j=j+k)
		{
			maze[mlen++]=arr[j]; 
		}
		dp[0]=maze[0];
		for(j=1;j<mlen;j++)//dp[j]与dp[j-1]不能匹配但可以与dp[j-2]匹配，这里运用了dp的思想推导
		{
			if(j==1)
			dp[j]=max(dp[j-1],maze[j]);//这里没有dp[j-2]
			else
			dp[j]=max(dp[j-1],dp[j-2]+maze[j]);//取两者最大值
		}
		sum+=dp[mlen-1];
	}
	return sum;
}
int main()
{
	int num,i;
	scanf("%d%d",&n,&k);
	for(i=0;i<n;i++)
	{
		scanf("%d",&num);
		arr[num]++;
	}
	printf("%d\n",breach());
	return 0;
}
