
问题描述
小明对搭积木非常感兴趣。他的积木都是同样大小的正立方体。
在搭积木时，小明选取 m 块积木作为地基，将他们在桌子上一字排开，中间不留空隙，并称其为第0层。
随后，小明可以在上面摆放第1层，第2层，……，最多摆放至第n层。摆放积木必须遵循三条规则：
规则1：每块积木必须紧挨着放置在某一块积木的正上方，与其下一层的积木对齐；
规则2：同一层中的积木必须连续摆放，中间不能留有空隙；
规则3：小明不喜欢的位置不能放置积木。
其中，小明不喜欢的位置都被标在了图纸上。图纸共有n行，从下至上的每一行分别对应积木的第1层至第n层。每一行都有m个字符，字符可能是‘.’或‘X’，其中‘X’表示这个位置是小明不喜欢的。
现在，小明想要知道，共有多少种放置积木的方案。他找到了参加蓝桥杯的你来帮他计算这个答案。
由于这个答案可能很大，你只需要回答这个答案对1000000007(十亿零七)取模后的结果。
注意：地基上什么都不放，也算作是方案之一种。
【输入格式】
输入数据的第一行有两个正整数n和m，表示图纸的大小。
随后n行，每行有m个字符，用来描述图纸 。每个字符只可能是‘.’或‘X’。
【输出格式】
输出一个整数，表示答案对1000000007取模后的结果。
【样例输入1】
2 3
…X
.X.
【样例输出1】
4
【样例说明1】
成功的摆放有（其中O表示放置积木）：
(1)
…X
.X.
(2)
…X
OX.
(3)
O.X
OX.
(4)
…X
.XO
【样例输入2】
3 3
…X
.X.
…
【样例输出2】
16
【数据规模约定】
对于10%的数据，n=1，m<=30；
对于40%的数据，n<=10，m<=30；
对于100%的数据，n<=100，m<=100。
资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗 < 1000ms
请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。
注意：
main函数需要返回0;
只使用ANSI C/ANSI C++ 标准;
不要调用依赖于编译环境或操作系统的特殊函数。
所有依赖的函数必须明确地在源文件中 #include 
不能通过工程设置而省略常用头文件。
提交程序时，注意选择所期望的语言类型和编译器类型。
代码
dfs超时！！！！！！

#include<stdio.h>
#include<stdlib.h>

int n, m;
char arr[100][101] = { 0 };
int count = 0;

int check(int x, int y)
{
	int i;
	int maze[100] = { 0 };
	int len = 0;
	if (arr[x][y] == 'X')
		return 0;
	if (x != n - 1 && arr[x + 1][y] != 'O')
		return 0;
	for (i = 0; i < m; i++)
	{
		if (i == y)
		{
			maze[len++] = i;
		}
		else if (arr[x][i] == 'O')
		{
			maze[len++] = i;
		}
	}
	for (i = 0; i < len-1; i++)
	{
		if (maze[i] + 1 != maze[i+1])
			return 0;
	}
	return 1;
}
void dfs(int x, int y)
{
	if (x == -1)
	{
		count = (count + 1) % 1000000007;
		return;
	}
	if (check(x, y) == 1)//是否能够放置积木
	{
		dfs(x - (y + 1) / m, (y + 1) % m);//不放置

		arr[x][y] = 'O';
		dfs(x - (y + 1) / m, (y + 1) % m);//放置
		arr[x][y] = '.';
	}
	else
		dfs(x - (y + 1) / m, (y + 1) % m);//搜索下一个位置
}
int main()
{
	int i, j, k;
	scanf("%d%d", &n, &m);
	for (i = 0; i < n; i++)
	{
		scanf("%s", &arr[i]);
	}
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < m; j++)
		{
			if (arr[i][j] == 'X')
			{
				for (k = 0; k < i; k++)
					arr[k][j] = 'X';
			}
		}
	}
	dfs(n - 1, 0); 
	printf("%d\n", count);
	return 0;
}
