List.h

#ifndef _LIST_H_
#define _LIST_H_

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef int LTDataType;
typedef struct ListNode
{
	LTDataType _data;
	struct ListNode* _next;
	struct ListNode* _prev;
}ListNode;
typedef struct List
{
	ListNode* _head;
}List;
void ListInit(List* plist);
void ListDestory(List* plist);
void ListPushBack(List* plist, LTDataType x);
void ListPopBack(List* plist);
void ListPushFront(List* plist, LTDataType x);
void ListPopFront(List* plist);
ListNode* ListFind(List* plist, LTDataType x);

void ListInsertFront(ListNode* pos, LTDataType x);
void ListInsertBack(ListNode* pos, LTDataType x);

void ListErase(ListNode* pos);
void ListRemove(List* plist, LTDataType x);
void ListPrint(List* plist);


#endif /*_LIST_H_*/

#include"List.h"

void ListInit(List* plist)
{
	plist->_head = (ListNode*)malloc(sizeof(ListNode));
	plist->_head->_next = plist->_head;
	plist->_head->_prev = plist->_head;
}
void ListDestory(List* plist)
{
	ListNode* pt = plist->_head->_next;
	while (pt != plist->_head)
	{
		pt = pt->_next;
		free(pt->_prev);
	}
	plist->_head->_next = plist->_head;
	plist->_head->_prev = plist->_head;
}
void ListPushBack(List* plist, LTDataType x)//尾插
{
	ListNode* pt = (ListNode*)malloc(sizeof(ListNode));
	if (pt == NULL)
	{
		printf("尾插失败");
		return;
	}
	pt->_data = x;
	plist->_head->_prev->_next = pt;
	pt->_prev = plist->_head->_prev;
	pt->_next = plist->_head;
	plist->_head->_prev = pt;
}
void ListPopBack(List* plist)//尾删
{
	ListNode* pt = plist->_head->_prev;
	pt->_prev->_next = pt->_next;
	pt->_next->_prev = pt->_prev;
	free(pt);
}
void ListPushFront(List* plist, LTDataType x)//头插
{
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	if (node == NULL)
	{
		printf("头插失败\n");
		return;
	}
	node->_data = x;
	node->_next = plist->_head->_next;
	plist->_head->_next->_prev = node;
	plist->_head->_next = node;
	node->_prev = plist->_head;
}
void ListPopFront(List* plist)//头删
{
	ListNode* pt = plist->_head->_next;
	plist->_head->_next = pt->_next;
	pt->_next->_prev = plist->_head;
	free(pt);
}
ListNode* ListFind(List* plist, LTDataType x)//查找
{
	ListNode* pt = plist->_head->_next;
	while (pt != plist->_head)
	{
		if (pt->_data == x)
			return pt;
		pt = pt->_next;
	}
	return NULL;
}

void ListInsertFront(ListNode* pos, LTDataType x)//前插入
{
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	if (node == NULL)
	{
		printf("前插失败\n");
		return;
	}
	node->_data = x;
	pos->_prev->_next = node;
	node->_prev = pos->_prev;
	node->_next = pos;
	pos->_prev = node;
}

void ListInsertBack(ListNode* pos, LTDataType x)//后插入
{
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	if (node == NULL)
	{
		printf("前插失败\n");
		return;
	}
	node->_data = x;
	node->_next = pos->_next;
	pos->_next->_prev = node;
	pos->_next = node;
	node->_prev = pos;
}
void ListErase(ListNode* pos)//删除节点
{
	pos->_prev->_next = pos->_next;
	pos->_next->_prev = pos->_prev;
	free(pos);
}
void ListRemove(List* plist, LTDataType x)//删除值为x的结点
{
	ListNode* pt = plist->_head->_next;
	while (pt != plist->_head)
	{
		if (pt->_data == x)
		{
			pt->_prev->_next = pt->_next;
			pt->_next->_prev = pt->_prev;
			ListNode* node = pt;
			pt = pt->_next;
			free(node);
			continue;
		}
		pt = pt->_next;
	}
}
void ListPrint(List* plist)
{
	ListNode* pt = plist->_head->_next;
	while (pt != plist->_head)
	{
		printf("%d ", pt->_data);
		pt = pt->_next;
	}
	printf("\n");
}
void ListMerge(List* plist1, List* plist2)//将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成 的.
{
	ListNode* p1 = plist1->_head->_next;
	ListNode* p2 = plist2->_head->_next;
	ListNode* pt2 = p2->_next;
	while (p2 != plist2->_head&&p1 != plist1->_head)
	{
		if (p1->_data > p2->_data)
		{
			p1->_prev->_next = p2;
			p2->_prev = p1->_prev;
			p2->_next = p1;
			p1->_prev = p2;
			p2 = pt2;
			pt2 = p2->_next;
		}
		else
		{
			p1 = p1->_next;
		}
	}
	if (p2 != plist2->_head)
	{
		plist1->_head->_prev->_next = p2;
		p2->_prev = plist1->_head->_prev;
		plist2->_head->_prev->_next = plist1->_head;
		plist1->_head->_prev = plist2->_head->_prev;
	}
}
List* ListPopDitto(List* plist)// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头 指针
{
	ListNode* pt = plist->_head->_next;
	while (pt->_next != plist->_head)
	{
		if (pt->_data == pt->_next->_data)
		{
			pt->_next = pt->_next->_next;
			pt->_next->_prev = pt;
			continue;
		}
		pt = pt->_next;
	}
	return plist;
}

main.c

#include"List.h"

int main()
{
	List test;
	ListInit(&test);
	ListPushBack(&test, 1);
	ListPushBack(&test, 1);
	ListPushBack(&test, 2);
	ListPushBack(&test, 3);
	ListPushBack(&test, 4);
	ListPushBack(&test, 5);
	ListPushBack(&test, 5);
	ListPushFront(&test, 6);
	ListPushFront(&test, 7);
	ListPushFront(&test, 8);
	ListPushFront(&test, 9);
	ListPrint(&test);
	ListRemove(&test, 5);
	ListPrint(&test);
	system("pause");
	return 0;
}
