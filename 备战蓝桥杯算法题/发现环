
问题描述

小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。

不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。

为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？

输入

第一行包含一个整数N。
以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。

对于30%的数据，1 <= N <= 1000
对于100%的数据, 1 <= N <= 100000， 1 <= a, b <= N

输入保证合法。

输出

按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。

样例输入：
5
1 2
3 1
2 4
2 5
5 3

样例输出：
1 2 3 5

资源约定：
峰值内存消耗 < 256M
CPU消耗 < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。
思考
计算每个点的度数。度数为1的点不可能在环上，那么与该点唯一相连的边也就不在环上了，可以删去。删去这条边后，这边的另一个端点度数减去1，如果因此而导致它的度数变为1了，同样说明该点不在环上，可以去掉，不断重复以上操作，直到没有边可以删去。
代码
超时了，只过了30%的数据
测试链接：发现环

#include<stdio.h>
#include<math.h>
#include<windows.h>

int n;
int maze[100001]={0};
int arr[100000][2]={0};

void strike(int k)
{
	int i;
	for(i=0;i<n;i++)
	{
		if(arr[i][0]==k)
		{
			maze[arr[i][1]]--;
			arr[i][0]=arr[i][1]=0;
			break;
		}
		else if(arr[i][1]==k)
		{
			maze[arr[i][0]]--;
			arr[i][0]=arr[i][1]=0;
			break;
		}
		
	}
}
int main()
{
	int i,t=1;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	{
		scanf("%d%d",&arr[i][0],&arr[i][1]);
		maze[arr[i][0]]++;
		maze[arr[i][1]]++;
	}
	while(t)
	{
		t=0;
		for(i=1;i<=n;i++)
		{
			if(maze[i]==1)
			{
				t=1;
				maze[i]=0;
				strike(i);
			}
		}
	}
	for(i=1;i<=n;i++)
	{
		if(maze[i]==2)
		printf("%d ",i);
	}
	printf("\n");
	return 0;
}
