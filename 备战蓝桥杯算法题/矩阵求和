
问题描述
经过重重笔试面试的考验，小明成功进入 Macrohard 公司工作。
今天小明的任务是填满这么一张表：
表有 n 行 n 列，行和列的编号都从1算起。
其中第 i 行第 j 个元素的值是 gcd(i, j)的平方，
gcd 表示最大公约数，以下是这个表的前四行的前四列：
1 1 1 1
1 4 1 4
1 1 9 1
1 4 1 16
小明突然冒出一个奇怪的想法，他想知道这张表中所有元素的和。
由于表过于庞大，他希望借助计算机的力量。
「输入格式」
一行一个正整数 n 意义见题。
「输出格式」
一行一个数，表示所有元素的和。由于答案比较大，请输出模 (10^9 + 7)(即：十亿零七) 后的结果。
「样例输入」
4
「样例输出」
48
「数据范围」
对于 30% 的数据，n <= 1000
存在 10% 的数据，n = 10^5
对于 60% 的数据，n <= 10^6
对于 100% 的数据，n <= 10^7
资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗 < 2000ms
请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。
注意：
main函数需要返回0;
只使用ANSI C/ANSI C++ 标准;
不要调用依赖于编译环境或操作系统的特殊函数。
所有依赖的函数必须明确地在源文件中 #include
不能通过工程设置而省略常用头文件。

思考
这个题不用创建数组然后相加，直接可以放入累加器中累加，问题在于如何降低时间复杂度，我们可以减少调用函数的次数，不使用递归，矩阵是个对称矩阵，减少循环次数，除了这些想不到什么了
测试数据只能过1000以内的！！！

代码

#include<stdio.h>
#define mod 1000000007

int gcd(int i, int j)
{
	int t = 0;
	while (j != 0)
	{
		t = i % j;
		i = j;
		j = t;
	}
	return i;
}

int main()
{
	int n;
	int i, j, t;
	int sum = 0;

	scanf("%d", &n);
	sum = 2 * n - 1;
	for (i = 2; i <= n; i++)
	{
		for (j = i + 1; j <= n; j++)
		{
			t = gcd(i, j);
			sum = sum + 2 * t*t;
			sum = sum % mod;
		}
	}
	for (i = 2; i <= n; i++)
	{
		t = gcd(i, i);
		sum = sum + t * t;
		sum = sum % mod;
	}
	printf("%d\n", sum);
	return 0;
}
