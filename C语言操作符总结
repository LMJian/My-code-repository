算术操作符
    +    -    *     /     %

1.除了%操作符以外，其他操作符可以作用于整数和浮点数。
2.对于/操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
3.%操作符的两个操作数必须为整数。返回的是整除之后的余数。

移位操作符
<<    左移操作符
>>    右移操作符

左移操作符移位规则
左边抛弃，右边补0

num<<1                  实际上num在没被赋值的情况下，自身的值不会变化。

右移操作符移位规则
首先右移运算分为两种：
1.逻辑移位 左边用0填充，右边丢弃
2.算术移位 左边用原该值的符号位填充，右边丢弃
警告：对于移位操作符，不要移动负数位，这个是未定义的。例如：

int num=10;
num>>-1;//error

位操作符
位操作符有：

&     //按位与
|      //按位或
^     //按位异或
注：他们的操作数必须是整数。

赋值操作符
赋值操作符是一个很棒的操作符，他可以让你得到一个你之前不满意的值，也就是你可以给自己重新赋值。

int weight =120;        //体重
weight=89;     // 不满意就赋值
double salary=10000.0;
salary=20000.0;// 使用赋值操作符赋值。

赋值操作符可以连续使用，比如：
int a=10;
int x=0;
int y=20;
a=x=y+1;//连续赋值
这样的代码感觉怎么样？

那同样的语义，你看看：
x=y+1;
a=x;
这样的写法是不是更加清晰爽朗而且易于调试。

复合赋值符
+= 
-=
*=
/=
%=
>>=
<<=
&=
|=
^=

这些运算符都可以写成复合的效果。比如：

int x=10;
x=x+10;
x+=10;//复合赋值
//其他运算符一样的道理，这样写更加简洁

单目操作符
单目操作符有哪些呢？

！          逻辑反操作
-           负值
+           正值
&           取地址
sizeof      操作数的类型长度（以字节为单位）
~           对一个数的二进制按位取反
--          前置，后置--
++          前置，后置++
*           间接访问操作符（解引用操作符）
（类型）     强制类型转换

演示代码

#include<stdio.h>
int main()
{
		int a=-10;
		int *p=NULL;
		printf("%d\n",!2);
		printf("%d\n",!0);
		a=-a;
		p=&a;
		printf("%d\n",sizeof(a));
		printf("%d\n",sizeof(int));
		printf("%d\n",sizeof a);    //这样写行不行？
		printf("%d\n",sizeof int);   //这样写行不行？
		return 0；
}

关于sizeof其实我们见过，可以求变量（类型）所占空间的大小。

关系操作符
>
>=
<
<=
!=         用于测试“不相等”
==         用于测试“相等”

我们要注意一些运算符使用时候的陷阱。
警告：在编程的过程中==和=不小心写错，导致错误。

逻辑操作符
&&         逻辑与
||         逻辑或
1
2
区分逻辑与和按位与区分逻辑或和按位或

1&2------>0
1&&2------>1

1|2------>3
1||2------>1

逻辑与和或的特点
360笔试题

#include<stdio.h>
int main()
{
	int i = 0,a = 0,b = 2,c = 3,d = 4;
	i= a++ && ++b && d++;
	//i=a++||++b||d++
	printf("a=%d\n,b=%d\n,c=%d\n,d=%d\n",a,b,c,d);
	return 0;
} 
//程序输出的结果是什么？

条件操作符
exp1？exp2:exp3
1
练习

1.
  if(a>5)
    b=3;
  else
    b=-3;
转换成条件表达式，是什么样？

2.使用条件表达式实现找两个数中较大值。

逗号表达式
exp1,exp2,exp3,...expN
1
逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果

//代码1
int a=1;
int b=2;
int c=(a>b,a=b+10,a,b=a+1);//逗号表达式
c是多少？

//代码2
if（a=b+1,c=a/2,d>0)

//代码3
a=get_val();
count_val(a);
while(a>0)
{
	//业务处理
	a=get_val();
	count_val(a);
}
如果使用逗号表达式，改写：
while(a=get_val(),count_val(a),a>0)
{
	//业务处理
}

下标引用，函数调用和结构成员
1.[ ] 下标引用操作符
操作数：一个数组名+一个索引值

int arr[10];//创建数组
arr[9]=10;//实用下标引用操作符。
[ ]的两个操作数是arr和9。

2.（）函数调用操作符 接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。

#include <stdio.h>
void test1（）
{
	printf("hehe\n");
}
void test2(）
{
 	printf("%s\n", str);
}
int main（）
{
   	 test1();            //实用( )作为函数调用操作符。
     test2("hello bit. ");//实用( )作为函数调用操作符。
     return 0;
}

3.访问一个结构的成员
.结构体.成员名
->结构体指针->成员名

 #include <stdio.h>
 struct Stu
 {
    char name [10] ;
    int age;
    char sex[5];
    double score;
 };
 void set_age1(struct Stu stu)
 {
 	stu.age = 18;
 }
 void set_ age2(struct Stu* pStu)
 {
    pStu->age = 18;//结构成员访问
 }
 int main()
 {
      struct Stu stu;
      struct stu* pStu = &stu;//结构成员访问
      
      stu.age = 20;//结构成员访问
      set_ age1(stu);
      
      pStu->age = 20;//结构成员访问
      set _age2(pstu);
      return 0;
  }

表达式求值
表达式求值的顺序一部分是由操作符的优先级和结合性决定。
同样,有些表达式的操作数在求值的过程中可能需要转换为其他类型。

隐式类型转换
C的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度,表达式中的字符和短整型操作数在使用之前被转换为普通整型,这种转换称为整型提升。
整型提升的意义:

表达式的整型运算要在CPU的相应运算器件内执行, CPU内整型运算器(ALU)的操作数的字节长度-般就是int的字节长度,同时也是CPU的通用寄存器的长度。
因此,即使两个char类型的相加,在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU ( general-purpose CPU )是难以直接实现两个8比特字节直接相加运算(虽然机器指令中可能有这种字节相加指令)。所以,表达式中各种长度可能小于int长度的整型值,都必须先转换为int或unsigned int ,然后才能送入CPU去执行运算。

      //实例1
      char a,b,c;
      ...
      a=b+c;

b和c的值被提升为普通整型,然后再执行加法运算。
加法运算完成之后,结果将被截断,然后再存储于a中。
如何进行整体提升呢?

整形提升是 按照变量的数据类型的符号位来提升的

  //负数的整形提升
  char c1 = -1;
  变量c1的二进制位(补码)中只有8个比特位:
     111111
  因为char 为有符号的char
  所以整形提升的时候,高位补充符号位,即为1提升之后的结果是:
  1111111111111111111111

 //正数的整形提升
 char c2 = 1;
   变量c2的二进制位(补码)中只有8个比特位:
   00000001
   因为char 为有符号的char
   所以整形提升的时候,高位补充符号位,即为0提升之后的结果是:
   0000000000000000000000001
   //无符号整形提升,高位补0
   
整形提升的例子:

//实例1  
    int main()
	{  
     char a = 0xb6;
     short b = 0xb600;
     int c = 0x6000000;
     if(a==0xb6)
      printf("a");
     if(b==0xb600)
      printf("b");
     if(c=o66000000)
      printf("c");
     return 0;
    }

突例1中的a,b要进行整形提升,但是c不需要整形提升a,b整形提升之后,変成了负数，所以表达式a== 0xb6 , b0xb600的結果是假,但是c不发生整形提升，则表达式c0xb600000的結果是真.

所程序输出的結果是: c

//实例2
int main（）
{   
  	char c=1;
	printf("%u\n"，sizeof(c));
	printf("%u\n"，sizeof(+c));
	printf("%u\n", sizeof(!c));
	return 0;
}

突例2中的,c只要参与表达式运算,就会发生整形提升,表达式+c ,就会岌生提升,所以sizeof(+c)是4个字节.
表达式-c也会友生整形提升,所以sizeof(-c)是4个字节,但是sizeof( c ) ,就是1个字节.

算术转换
如果某个操作符的各个操作数属于不同的类型,那么除非其中一个操作数的转换为另一个操作数的类型,否则操作就无法进行。下面的层次体系称为寻常算术转换。

      long double
      double
      float
      unsigned long int
      long int
      unsigned int
      int

如果某个操作数的类型在上面这个列表中排名较低,那么首先要转换为另外-一个操作数的类型后执行运算。警告:但是算术转换要合理,要不然会有一些潜在的问题。

  float f = 3.14;
  int num = f;//隐式转换,会有精度丢失
